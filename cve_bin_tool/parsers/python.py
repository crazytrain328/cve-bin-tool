# Copyright (C) 2023 Intel Corporation
# SPDX-License-Identifier: GPL-3.0-or-later

import json
import re
import subprocess
from re import MULTILINE, compile, search

from packaging.version import parse as parse_version

from cve_bin_tool.parsers import Parser
from cve_bin_tool.strings import parse_strings


class PythonRequirementsParser(Parser):
    """
    Parser for Python requirements files.

    This parser is designed to parse Python requirements files (usually named
    requirements.txt) and generate PURLs (Package URLs) for the listed packages.
    """

    def __init__(self, cve_db, logger):
        """Initialize the parser."""
        super().__init__(cve_db, logger)
        self.purl_pkg_type = "pypi"

    def generate_purl(self, product, version, vendor, qualifier={}, subpath=None):
        """Generates PURL after normalizing all components."""
        product = re.sub(r"[^a-zA-Z0-9._-]", "", product).lower()
        version = re.sub(r"[^a-zA-Z0-9.+-]", "", version)
        vendor = "UNKNOWN"  # Vendor is typically not used for Python packages

        if not product or not version:
            return None

        purl = super().generate_purl(
            product,
            version,
            vendor,
            qualifier,
            subpath,
        )

        return purl

    def run_checker(self, filename):
        """
        Parse the requirements file and yield PURLs for the listed packages.

        Args:
            filename (str): The path to the requirements file.

        Yields:
            str: PURLs for the packages listed in the file.
        """
        self.filename = filename
        try:
            # Use pip to parse the requirements file and get package metadata
            output = subprocess.check_output(
                [
                    "pip3",
                    "install",
                    "-r",
                    self.filename,
                    "--dry-run",
                    "--ignore-installed",
                    "--report",
                    "-",
                    "--quiet",
                ],
                stderr=subprocess.STDOUT,
            )
        except subprocess.CalledProcessError as e:
            self.logger.error(e.output)
            pip_version = str(subprocess.check_output(["pip3", "--version"]))
            pip_version = pip_version.split(" ")[1]
            if parse_version(pip_version) < parse_version("22.2"):
                self.logger.error(
                    f"{filename} not scanned: pip --dry-run was unable to get package versions."
                )
                self.logger.error(
                    "pip version >= 22.2 is required to scan Python requirements files."
                )
        else:
            lines = json.loads(output)
            for line in lines["install"]:
                product = line["metadata"]["name"]
                version = line["metadata"]["version"]
                # Generate the PURL using the normalized values
                purl = self.generate_purl(product, version, "UNKNOWN")
                if purl:
                    self.logger.debug(f"Generated PURL: {purl}")
                    yield purl
            self.logger.debug(f"Done scanning file: {self.filename}")


class PythonParser(Parser):
    """
    Parser for Python package metadata files.

    This parser is designed to parse Python package metadata files (usually named
    PKG-INFO or METADATA) and generate PURLs (Package URLs) for the package.
    """

    def __init__(self, cve_db, logger):
        """Initialize the parser."""
        super().__init__(cve_db, logger)
        self.purl_pkg_type = "pypi"

    def generate_purl(self, product, version, vendor, qualifier={}, subpath=None):
        """Generates PURL after normalizing all components."""
        product = re.sub(r"[^a-zA-Z0-9._-]", "", product).lower()
        version = re.sub(r"[^a-zA-Z0-9.+-]", "", version)
        vendor = "UNKNOWN"  # Vendor is typically not used for Python packages

        if not product or not version:
            return None

        purl = super().generate_purl(
            product,
            version,
            vendor,
            qualifier,
            subpath,
        )

        return purl

    def run_checker(self, filename):
        """
        Parse the package metadata file and yield a PURL for the package.

        Args:
            filename (str): The path to the package metadata file.

        Yields:
            str: PURL for the package described in the file.
        """
        self.filename = filename
        lines = parse_strings(self.filename)
        lines = "\n".join(lines.splitlines()[:3])
        try:
            # Extract package name and version from metadata
            product = search(compile(r"^Name: (.+)$", MULTILINE), lines).group(1)
            version = search(compile(r"^Version: (.+)$", MULTILINE), lines).group(1)
            # Generate the PURL using the normalized values
            purl = self.generate_purl(product, version, "UNKNOWN")
            if purl:
                self.logger.debug(f"Generated PURL: {purl}")
                yield purl
        except AttributeError:
            self.logger.debug(f"{filename} is an invalid METADATA/PKG-INFO")
        self.logger.debug(f"Done scanning file: {filename}")
