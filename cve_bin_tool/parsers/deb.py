# Copyright (C) 2022 Intel Corporation
# SPDX-License-Identifier: GPL-3.0-or-later

import os
import re
from typing import List, Optional, Tuple

from cve_bin_tool.parsers import Parser
from cve_bin_tool.util import ProductInfo, ScanInfo


class DebParser(Parser):
    def __init__(self, cve_db, logger):
        super().__init__(cve_db, logger)

    def find_vendor(self, product, version):
        """Find vendor for Debian product"""
        vendor_package_pair = self.cve_db.get_vendor_product_pairs(product)
        if not vendor_package_pair and "-" in product:
            self.logger.debug(f"Trying alternative product name for {product}")
            alternative_product = product.replace("-", "_")
            vendor_package_pair = self.cve_db.get_vendor_product_pairs(
                alternative_product
            )
        if vendor_package_pair:
            info = []
            for pair in vendor_package_pair:
                vendor = pair["vendor"]
                file_path = self.filename
                self.logger.debug(f"{file_path} {product} {version} by {vendor}")
                info.append(ScanInfo(ProductInfo(vendor, product, version), file_path))
            return info
        else:
            return None
    # This method parses the additional required dependencies like requirements, suggestions and recommendations.
    def parse_dependencies(self, data, regex):
        """Parse dependencies from control file"""
        dependencies = []
        matches = regex.finditer(data)
        for match in matches:
            dependencies.extend([dep.strip() for dep in match.group(1).split(",")])
        return dependencies

    def parse_control_file(
        self, control_data
    ) -> Tuple[Optional[str], Optional[str], List[str]]:
        """Parse the control file to extract package, version, and dependencies"""
        package_re = re.compile(r"Package: (.+)")
        version_re = re.compile(r"Version: (.+)")
        depends_re = re.compile(r"Depends: ([^\n]+)")
        recommends_re = re.compile(r"Recommends: ([^\n]+)")
        suggests_re = re.compile(r"Suggests: ([^\n]+)")

        product = package_re.search(control_data)
        version = version_re.search(control_data)
        dependencies = self.parse_dependencies(control_data, depends_re)
        recommendations = self.parse_dependencies(control_data, recommends_re)
        suggestions = self.parse_dependencies(control_data, suggests_re)

        all_dependencies = dependencies + recommendations + suggestions

        return (
            product.group(1) if product else None,
            version.group(1) if version else None,
            all_dependencies,
        )

    def run_checker(self, filename):
        """Process .deb control file"""
        self.logger.debug(f"Scanning .deb control file: {filename}")
        if not os.path.exists(filename):
            self.logger.error(f"File not found: {filename}")
            return
        try:
            with open(filename) as file:
                control_data = file.read()
            product, version, dependencies = self.parse_control_file(control_data)
            if product and version:
                product_info = self.find_vendor(product, version)
                if product_info:
                    yield from product_info
                for dependency in dependencies:
                    dep_name, dep_version = dependency.split(" ")[0], None
                    if "(" in dependency:
                        dep_name, dep_version = (
                            dependency.split(" ")[0],
                            dependency.split(" ")[1],
                        )
                    dep_info = self.find_vendor(dep_name, dep_version)
                    if dep_info:
                        yield from dep_info
            else:
                self.logger.debug(f"No product/version found in {filename}")
        except Exception as e:
            self.logger.error(f"Error processing file {filename}: {e}")
        self.logger.debug(f"Done scanning file: {filename}")
